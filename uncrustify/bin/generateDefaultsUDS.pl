#!/usr/bin/perl

use v5.36;
use strict;

use Getopt::Long;
use FindBin qw($Bin $Script);
use lib "$Bin/.";

### Global variables used by this script and the module UDocTools
our $verbose = 0;  # set by user on command line
our $ucBin;        # set by user on command line (default is $Bin)

use UDocTools qw(dumpit getOption loadOptionDescriptions SayError Fatal);

### Global variables used by this script
$|=1;
my $binDir    =  $Bin;                  # where to find the uncrustify binary
my $outputDir = "$Bin/../uds/default";  # where to generated the .uds (Uncrustify Documentation Script) files
my @optKeys;

# Script name  (without the .pl) used in the error messages
$Script =~ s/^(.+)\.pl$/$1/i;

GetOptions (
  "bindir=s"     => \$binDir,    # string
  "option=s"     => \@optKeys,   # string
  "outputdir=s"  => \$outputDir, # string
  "verbose"      => \$verbose    # flag
) or Fatal("Invalid command line argument.");

$binDir .= '/'  if $binDir && $binDir !~ m(/$);
$ucBin   = "${binDir}uncrustify.exe";

my $err=0;
if( $binDir ){
    if( ! -d $binDir ){
        SayError("Path '$binDir' doesn't exist.");
        $err++;
    }elsif( ! -e $ucBin ){
        SayError("File '$ucBin' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --bindir is not defined.");
    $err++;
}

if( $outputDir ){
    if( ! -d $outputDir ){
        SayError("Path '$outputDir' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --outputDir is not defined.");
    $err++;
}

exit(3) if $err;

# a ref to a hash of hash   Used to collect info and then sort options by name
my $options = loadOptionDescriptions();

# dumpit('Options' => $options);

if( scalar(@optKeys) ){
    # The names provided by user looks like 'align_func_params_gap'
    # Generate a default uds file only for these options
    for my $optKey (@optKeys){
        if( $options->{$optKey} ){
            generateUDS($optKey)
        }else{
            SayError "Option --option $optKey is not a valid option";
        }
    }
    exit;
}

for my $optKey (sort keys %{$options} ){
    generateUDS($optKey);
}

exit;

sub generateUDS {
    my $optKey = shift;  # with space: 'align func params gap'
    return if $optKey eq 'header';

    my $udsFile = "$outputDir/$optKey.uds";
    open(my $fh, '>', $udsFile)
        || Fatal("Cannot create $udsFile\n$!");
    print $fh "==== INFO: AUTOGENERATED\n";

    my $opt = $options->{$optKey};
    my $type = lc ($opt->{EditorType}||'');
    if( $type eq 'boolean' ){
        generateUdsForBoolean($opt, $fh);
    }elsif( $type eq 'multiple' ){
        generateUdsForMultiple($opt, $fh);
    }elsif( $type eq 'numeric' ){
        generateUdsForNumeric($opt, $fh);
    }elsif( $type eq 'string' ){
        generateUdsForString($opt, $fh);
    }else{
        SayError("Type '$type' is unknown in option '$optKey'");
        $type = '';
    }
    if( $type ){
        say "Generate '$type' uds for $opt->{optKey} >> $udsFile";
    }
    close $fh;
}

sub generateUdsForBoolean {
    my $opt = shift;
    my $fh  = shift;
    print $fh join("\n",
      , "==== NAME: $opt->{optKey}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , "==== SET $opt->{optKey}=false"
      , "==== SET $opt->{optKey}=true"
    ) ;
}

sub generateUdsForMultiple {
    my $opt = shift;
    my $fh  = shift;
    print $fh join("\n",
      , "==== NAME: $opt->{optKey}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , ''
    );
    my $choices = $opt->{Choices};
    $choices =~ s!^"(.*)"$!$1!;  # cleanup only required by 'indent_with_tabs'
    my @choices = map {/(\w+)$/; $1} split('\|', $choices);
    for my $value (@choices){
        print $fh "==== SET $opt->{optKey}=$value\n";
    }
}

sub generateUdsForNumeric {
    my $opt = shift;
    my $fh  = shift;

    my $maxVal  = $opt->{MaxVal};
    my $minVal  = $opt->{MinVal};
    my $default = $opt->{ValueDefault} || 0;
    $maxVal = $default if $maxVal eq '';
    $minVal = $default if $minVal eq '';

    print $fh join("\n",
      , "==== NAME: $opt->{optKey}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , ''
    );
    if( $minVal==0 && $maxVal==16 ){
        for my $value (0, 5, 10, 16){
            print $fh "==== SET $opt->{optKey}=$value\n";
        }
    }elsif( 0 < ($maxVal - $minVal) < 5 ){
        for( my $value=$minVal; $value<=$maxVal; $value++ ){
            print $fh "==== SET $opt->{optKey}=$value\n";
        }
    }else{
        print $fh "==== SET $opt->{optKey}=$default\n";
        print $fh "==== INFO: need to be tuned [$minVal .. $maxVal]\n";
    }
}

sub generateUdsForString {
    my $opt = shift;
    my $fh  = shift;
    # FIXME TBD...
}

__END__
