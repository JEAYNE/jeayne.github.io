#!/usr/bin/perl

use v5.36;
use strict;

use Getopt::Long;
use FindBin qw($Bin $Script);
use lib "$Bin/.";

### Global variables used by this script and the module UDocTools
our $verbose = 0;  # set by user on command line 
our $ucBin;        # set by user on command line (default is $Bin)

use UDocTools qw(dumpit getOption loadOptionDescriptions SayError Fatal);

### Global variables used by this script
$|=1;
my $binDir    =  $Bin;                  # where to find the uncrustify binary
my $outputDir = "$Bin/../uds/default";  # where to generated the .uds (Uncrustify Documentation Script) files

# Nom du script (sans pl) utilisÃ© dans les messages d'erreur
$Script =~ s/^(.+)\.pl$/$1/i;

GetOptions (
  "bindir=s"     => \$binDir,    # string
  "outputdir=s"  => \$outputDir, # string
  "verbose"      => \$verbose    # flag
) or Fatal("Invalid command line argument.");

$binDir .= '/'  if $binDir && $binDir !~ m(/$);
$ucBin   = "${binDir}uncrustify.exe";

my $err=0;
if( $binDir ){
    if( ! -d $binDir ){
        SayError("Path '$binDir' doesn't exist.");
        $err++;
    }elsif( ! -e $ucBin ){
        SayError("File '$ucBin' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --bindir is not defined.");
    $err++;    
}

if( $outputDir ){
    if( ! -d $outputDir ){
        SayError("Path '$outputDir' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --outputDir is not defined.");
    $err++;
}

exit(3) if $err;

my $ucVersion = getOption('--version');
$ucVersion = (split('-', $ucVersion))[1];
say "Running Uncrustify version $ucVersion";

# a ref to a hash of hash   Used to collect info and then sort options by name
my $options = loadOptionDescriptions();

# dumpit('Options' => $options);

my ($sec,$min,$hour,$mday,$mon,$year) = gmtime();
my $now = sprintf("%04d-%02d-%2d %02d:%02d:%02d UTC", $year+1900, $mon+1, $mday, $hour, $min, $sec);
    
for my $optKey (sort keys %{$options} ){
    (my $optName = lc($optKey) ) =~ s/ /_/g;
    next if $optKey eq 'header';
    my $udsPath = "$outputDir/$optName.uds";
    open(my $fh, '>', $udsPath)
        || Fatal("Cannot read $udsPath\n$!");
    print $fh "==== AUTOGENERATED $now $ucVersion\n";

    my $opt = $options->{$optKey};
    $opt->{optName} = $optName;
    my $type = lc ($opt->{EditorType}||'');
    if( $type eq 'boolean' ){
        generateUdsForBoolean($opt, $fh);
    }elsif( $type eq 'multiple' ){
        generateUdsForMultiple($opt, $fh);
    }elsif( $type eq 'numeric' ){
        generateUdsForNumeric($opt, $fh);
    }elsif( $type eq 'string' ){
        generateUdsForString($opt, $fh);
    }else{
        SayError("Type '$type' is unknown in option '$optName'");
    }

    close $fh;
}

sub generateUdsForBoolean {
    my $opt = shift;
    my $fh  = shift;
    say "Generate 'boolean' uds for $opt->{optName}";
    print $fh join("\n",
      , "==== NAME: $opt->{optName}"
      , '==== INPUT'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , '==== WITH false'
      , '==== WITH true'
    ) ;
}

sub generateUdsForMultiple {
    my $opt = shift;
    say "Generate 'multiple' uds for $opt->{optName}"
    # TBD...
}

sub generateUdsForNumeric {
    my $opt = shift;
    say "Generate 'numeric' uds for $opt->{optName}"
    # TBD...
}

sub generateUdsForString {
    my $opt = shift;
    say "Generate 'string' uds for $opt->{optName}"
    # TBD...
}

__END__
