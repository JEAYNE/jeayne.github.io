#!/usr/bin/perl

use v5.36;
use strict;

use Getopt::Long;
use FindBin qw($Bin $Script);
use lib "$Bin/.";

### Global variables used by this script and the module UDocTools
our $verbose = 0;  # set by user on command line
our $ucBin;        # set by user on command line (default is $Bin)

use UDocTools qw(dumpit getOption loadOptionDescriptions SayError Fatal);

### Global variables used by this script
$|=1;
my $binDir    =  $Bin;                  # where to find the uncrustify binary
my $outputDir = "$Bin/../uds/default";  # where to generated the .uds (Uncrustify Documentation Script) files

# Nom du script (sans pl) utilisÃ© dans les messages d'erreur
$Script =~ s/^(.+)\.pl$/$1/i;

GetOptions (
  "bindir=s"     => \$binDir,    # string
  "outputdir=s"  => \$outputDir, # string
  "verbose"      => \$verbose    # flag
) or Fatal("Invalid command line argument.");

$binDir .= '/'  if $binDir && $binDir !~ m(/$);
$ucBin   = "${binDir}uncrustify.exe";

my $err=0;
if( $binDir ){
    if( ! -d $binDir ){
        SayError("Path '$binDir' doesn't exist.");
        $err++;
    }elsif( ! -e $ucBin ){
        SayError("File '$ucBin' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --bindir is not defined.");
    $err++;
}

if( $outputDir ){
    if( ! -d $outputDir ){
        SayError("Path '$outputDir' doesn't exist.");
        $err++;
    }
}else{
    SayError("Path --outputDir is not defined.");
    $err++;
}

exit(3) if $err;

my $ucVersion = getOption('--version');
$ucVersion = (split('-', $ucVersion))[1];
say "Running Uncrustify version $ucVersion";

# a ref to a hash of hash   Used to collect info and then sort options by name
my $options = loadOptionDescriptions();

# dumpit('Options' => $options);

my ($sec,$min,$hour,$mday,$mon,$year) = gmtime();
my $now = sprintf("%04d-%02d-%2d %02d:%02d:%02d UTC", $year+1900, $mon+1, $mday, $hour, $min, $sec);

for my $optKey (sort keys %{$options} ){
    (my $optName = lc($optKey) ) =~ s/ /_/g;
    next if $optKey eq 'header';
    my $udsPath = "$outputDir/$optName.uds";
    open(my $fh, '>', $udsPath)
        || Fatal("Cannot read $udsPath\n$!");
    print $fh "==== INFO: AUTOGENERATED $now $ucVersion\n";

    my $opt = $options->{$optKey};
    $opt->{optName} = $optName;
    my $type = lc ($opt->{EditorType}||'');
    if( $type eq 'boolean' ){
        generateUdsForBoolean($opt, $fh);
    }elsif( $type eq 'multiple' ){
        generateUdsForMultiple($opt, $fh);
    }elsif( $type eq 'numeric' ){
        generateUdsForNumeric($opt, $fh);
    }elsif( $type eq 'string' ){
        generateUdsForString($opt, $fh);
    }else{
        SayError("Type '$type' is unknown in option '$optName'");
    }

    close $fh;
}

sub generateUdsForBoolean {
    my $opt = shift;
    my $fh  = shift;
    say "Generate 'boolean' uds for $opt->{optName}";
    print $fh join("\n",
      , "==== NAME: $opt->{optName}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , '==== SET $opt->{optName}=false'
      , '==== SET $opt->{optName}=true'
    ) ;
}

sub generateUdsForMultiple {
    my $opt = shift;
    my $fh  = shift;
    say "Generate 'multiple' uds for $opt->{optName}";
    print $fh join("\n",
      , "==== NAME: $opt->{optName}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , ''
    );
    my $choices = $opt->{Choices};
    $choices =~ s!^"(.*)"$!$1!;  # cleanup only required by 'indent_with_tabs'
    my @choices = map {/(\w+)$/; $1} split('\|', $choices);
    for my $value (@choices){
        print $fh "==== SET $opt->{optName}=$value\n";
    }
}

sub generateUdsForNumeric {
    my $opt = shift;
    my $fh  = shift;

    my $maxVal = $opt->{MaxVal};
    my $minVal = $opt->{MinVal};
    return if $maxVal eq '';  # sometime Max is ''
    return if $minVal eq '';  # should not happen
    return if ($maxVal - $minVal) > 16;

    say "Generate 'numeric' uds for $opt->{optName}";
    print $fh join("\n",
      , "==== NAME: $opt->{optName}"
      , '==== CODE'
      , 'int main(int argc, char** argv){'
      , '  int n = 0;'
      , '  if(arg>=1){'
      , '    printf("Hello %s!\n", argv[1]);'
      , '    n=strlen(argv[1]);'
      , '  }else{'
      , '    puts("Hello world!");'
      , '  }'
      , '  return n;'
      , '}'
      , ''
    );
    if( $minVal==0 && $maxVal==16 ){
        for my $value (0, 5, 10, 16){
            print $fh "==== SET $opt->{optName}=$value\n";
        }
    }else{
        for( my $value=$minVal; $value<=$maxVal; $value++ ){
            print $fh "==== SET $opt->{optName}=$value\n";
        }
    }
}

sub generateUdsForString {
    my $opt = shift;
    my $fh  = shift;
    # TBD: say "Generate 'string' uds for $opt->{optName}"
}

__END__
